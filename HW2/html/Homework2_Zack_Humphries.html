
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Homework2_Zack_Humphries</title><meta name="generator" content="MATLAB 9.12"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-09-21"><meta name="DC.source" content="Homework2_Zack_Humphries.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Zack Humphries</a></li><li><a href="#3">Problem A</a></li><li><a href="#4">Problem B</a></li><li><a href="#5">Functions used for calculations</a></li></ul></div><h2 id="1">Zack Humphries</h2><p>COMP 521 HW2</p><pre class="codeinput">clc;       <span class="comment">% clear command window</span>
clear;     <span class="comment">% removes all saved variables</span>
close <span class="string">all</span>; <span class="comment">% close any open windows</span>
</pre><pre class="codeinput">h = 0.02;               <span class="comment">% sets h</span>
number_of_grids = 4;    <span class="comment">% grid sizes for error plot</span>
x_interval = -1+h : h : 1-h;    <span class="comment">% sets interval [-1 to 1] for xi with h gap</span>
</pre><h2 id="3">Problem A</h2><pre class="codeinput">[estimate_interval, actual_interval,estimate_middle,actual_middle] = <span class="keyword">...</span>
    problem_1(x_interval,h);    <span class="comment">% returns estimate vs actual and middle estimate vs actual for reference</span>

<span class="comment">% Plotting Problem A: Actual vs Estimate f''(x)</span>
plot(x_interval, actual_interval, <span class="string">'k-'</span>)
hold <span class="string">on</span>;
plot(x_interval, estimate_interval, <span class="string">'r--'</span>)
legend(<span class="string">"Actual"</span>, <span class="string">"Estimate"</span>)
xlabel(<span class="string">"x"</span>)
ylabel(<span class="string">"f''(x)"</span>)
title(<span class="string">"Problem A: Actual vs Estimate f''(x)"</span>)
hold <span class="string">off</span>


<span class="comment">% Returns all h intervals (ex. [h, h/2, h/4, h/8,...]) and the error</span>
<span class="comment">% approximation for each h/(2*n). Takes in problem_number (1 for A and 2</span>
<span class="comment">% for B)</span>
problem_number = 1; <span class="comment">% 1 for Problem A</span>
[h_interval, error_list] = grid_reduction(h,number_of_grids, problem_number);

<span class="comment">% Plotting Problem A: LogLog Plot</span>
figure(2)
loglog(h_interval, error_list, <span class="string">'r-'</span>)
legend(<span class="string">"Error Approximation"</span>)
xlabel(<span class="string">"Log(h)"</span>)
ylabel(<span class="string">"Log(Error)"</span>)
title(<span class="string">"Problem A: LogLog Plot"</span>)
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="Homework2_Zack_Humphries_01.png" alt=""> <h2 id="4">Problem B</h2><pre class="codeinput">[estimate_interval, actual_interval,estimate_middle,actual_middle] = <span class="keyword">...</span>
    problem_2(x_interval,h);

<span class="comment">% Plotting Problem B: Actual vs Estimate f''(x)</span>
figure(3)
plot(x_interval, actual_interval, <span class="string">'k-'</span>)
hold <span class="string">on</span>;
plot(x_interval, estimate_interval, <span class="string">'g--'</span>)
legend(<span class="string">"Actual"</span>, <span class="string">"Estimate"</span>)
xlabel(<span class="string">"x"</span>)
ylabel(<span class="string">"f''(x)"</span>)
title(<span class="string">"Problem B: Actual vs Estimate f''(x)"</span>)
hold <span class="string">off</span>

problem_number = 2; <span class="comment">% 2 for Problem B</span>
[h_interval, error_list] = grid_reduction(h,number_of_grids, problem_number);

<span class="comment">% Plotting Problem B: LogLog Plot</span>
figure(4)
loglog(h_interval, error_list, <span class="string">'g-'</span>)
legend(<span class="string">"Error Approximation"</span>)
xlabel(<span class="string">"Log(h)"</span>)
ylabel(<span class="string">"Log(Error)"</span>)
title(<span class="string">"Problem B: LogLog Plot"</span>)
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="Homework2_Zack_Humphries_02.png" alt=""> <img vspace="5" hspace="5" src="Homework2_Zack_Humphries_03.png" alt=""> <h2 id="5">Functions used for calculations</h2><pre class="codeinput"><span class="keyword">function</span> [h_interval, error_list] = grid_reduction(h,number_of_grids, problem_number)
    h_interval = zeros(1,number_of_grids);      <span class="comment">% sets empty array for future h/# values</span>
    error_list = zeros(1,number_of_grids);      <span class="comment">% sets empty array for error approximations</span>
    h_div = h;                                  <span class="comment">% initializes first h = h</span>
    <span class="keyword">for</span> n=1:number_of_grids
        h_interval(n) = h_div;                  <span class="comment">% replaces 0 in empty array with actual h/# value</span>
        interval = -1+h_div : h_div : 1-h_div;  <span class="comment">% makes fresh xi interval with h/# as gap</span>
        <span class="keyword">if</span> problem_number == 1      <span class="comment">% If problem A, returns estimate vs actual for each xi based on h/# gap AND estimate and actual middle value for loglog graph</span>
            [estimate_interval, actual_interval,estimate_middle,actual_middle] = <span class="keyword">...</span>
                problem_1(interval,h_div);
        <span class="keyword">elseif</span> problem_number == 2  <span class="comment">% If problem B...</span>
            [estimate_interval, actual_interval,estimate_middle,actual_middle] = <span class="keyword">...</span>
                problem_2(interval,h_div);
        <span class="keyword">end</span>
        error = (abs(estimate_middle-actual_middle))^(1.0/number_of_grids); <span class="comment">% error approximation</span>
        error_list(n) = error;                  <span class="comment">% replaces 0 in empty error_list array with error approximation</span>
        h_div = h/(n*2);                        <span class="comment">% sets new h value (h/(2*grid_size))</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [estimate_interval, actual_interval,estimate_middle,actual_middle] = <span class="keyword">...</span>
        problem_1(interval,h)                       <span class="comment">% Problem A</span>
    interval_length = length(interval);             <span class="comment">% saves number of xi's in x_interval</span>
    estimate_interval = zeros(1,length(interval));  <span class="comment">% makes empty array for estimate f"(x)</span>
    actual_interval = zeros(1,length(interval));    <span class="comment">% makes empty array for actual f"(x)</span>
    <span class="keyword">for</span> n=1:interval_length
        xi = interval(n);                           <span class="comment">% goes through each xi</span>
        ui = problem_1_f(xi);                       <span class="comment">% returns f(xi) for f"(xi) estimation</span>
        ui_plus = problem_1_f(xi + h);              <span class="comment">% returns f(xi+h) for f"(xi) estimation</span>
        ui_minus = problem_1_f(xi - h);             <span class="comment">% returns f(xi+h) for f"(xi) estimation</span>
        estimate_interval(n) = f_double_prime(ui_plus,ui,ui_minus,h);   <span class="comment">% estimate f"(xi)</span>
        actual_interval(n) = problem_1_f_double_prime(xi);              <span class="comment">% actual f"(xi)</span>
    <span class="keyword">end</span>
    estimate_middle = estimate_interval((interval_length+1)/2);         <span class="comment">% since x_interval will always have an odd number of values,</span>
    actual_middle = actual_interval((interval_length+1)/2);             <span class="comment">% (interval_length+1)/2 will always return middle estimate/actual</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [estimate_interval, actual_interval,estimate_middle,actual_middle] = <span class="keyword">...</span>
        problem_2(interval,h)                       <span class="comment">% Problem B</span>
    interval_length = length(interval);             <span class="comment">% ...</span>
    estimate_interval = zeros(1,length(interval));
    actual_interval = zeros(1,length(interval));
    <span class="keyword">for</span> n=1:interval_length
        xi = interval(n);
        ui = problem_2_f(xi);
        ui_plus = problem_2_f(xi + h);
        ui_minus = problem_2_f(xi - h);
        estimate_interval(n) = f_double_prime(ui_plus,ui,ui_minus,h);
        actual_interval(n) = problem_2_f_double_prime(xi);
    <span class="keyword">end</span>
    estimate_middle = estimate_interval((interval_length+1)/2);
    actual_middle = actual_interval((interval_length+1)/2);
<span class="keyword">end</span>

<span class="keyword">function</span> result = f_double_prime(ui_plus,ui,ui_minus,h)
    result = (ui_plus - (2*ui) + ui_minus)/(h^2);   <span class="comment">% centered finite difference approximation of f"(x)</span>
<span class="keyword">end</span>

<span class="keyword">function</span> result = problem_1_f(x)
    result = exp(x)*sin((pi*x)/2);  <span class="comment">% Returns f(x) for Problem A</span>
<span class="keyword">end</span>

<span class="keyword">function</span> result = problem_1_f_double_prime(x)
    result = -(1/4) * exp(x)*(((pi^2)-4)*sin(pi*x/2)-4*pi*cos(pi*x/2)); <span class="comment">% Returns actual f"(x) for Problem A</span>
<span class="keyword">end</span>

<span class="keyword">function</span> result = problem_2_f(x)
    result = 2*(cos(pi*x)^2)-1;  <span class="comment">% Returns f(x) for Problem B</span>
<span class="keyword">end</span>

<span class="keyword">function</span> result = problem_2_f_double_prime(x)
    result = 4*(pi^2)*((sin(pi*x)^2)-(cos(pi*x)^2)); <span class="comment">% Returns actual f"(x) for Problem B</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Zack Humphries
% COMP 521
% HW2

clc;       % clear command window
clear;     % removes all saved variables
close all; % close any open windows

%%
h = 0.02;               % sets h
number_of_grids = 4;    % grid sizes for error plot
x_interval = -1+h : h : 1-h;    % sets interval [-1 to 1] for xi with h gap

%% Problem A
[estimate_interval, actual_interval,estimate_middle,actual_middle] = ...
    problem_1(x_interval,h);    % returns estimate vs actual and middle estimate vs actual for reference

% Plotting Problem A: Actual vs Estimate f''(x)
plot(x_interval, actual_interval, 'k-')
hold on;
plot(x_interval, estimate_interval, 'rREPLACE_WITH_DASH_DASH')
legend("Actual", "Estimate")
xlabel("x")
ylabel("f''(x)")
title("Problem A: Actual vs Estimate f''(x)")
hold off


% Returns all h intervals (ex. [h, h/2, h/4, h/8,...]) and the error
% approximation for each h/(2*n). Takes in problem_number (1 for A and 2
% for B)
problem_number = 1; % 1 for Problem A
[h_interval, error_list] = grid_reduction(h,number_of_grids, problem_number);

% Plotting Problem A: LogLog Plot
figure(2)
loglog(h_interval, error_list, 'r-')
legend("Error Approximation")
xlabel("Log(h)")
ylabel("Log(Error)")
title("Problem A: LogLog Plot")
hold off

%% Problem B
[estimate_interval, actual_interval,estimate_middle,actual_middle] = ...
    problem_2(x_interval,h);

% Plotting Problem B: Actual vs Estimate f''(x)
figure(3)
plot(x_interval, actual_interval, 'k-')
hold on;
plot(x_interval, estimate_interval, 'gREPLACE_WITH_DASH_DASH')
legend("Actual", "Estimate")
xlabel("x")
ylabel("f''(x)")
title("Problem B: Actual vs Estimate f''(x)")
hold off

problem_number = 2; % 2 for Problem B
[h_interval, error_list] = grid_reduction(h,number_of_grids, problem_number);

% Plotting Problem B: LogLog Plot
figure(4)
loglog(h_interval, error_list, 'g-')
legend("Error Approximation")
xlabel("Log(h)")
ylabel("Log(Error)")
title("Problem B: LogLog Plot")
hold off

%% Functions used for calculations
function [h_interval, error_list] = grid_reduction(h,number_of_grids, problem_number)
    h_interval = zeros(1,number_of_grids);      % sets empty array for future h/# values
    error_list = zeros(1,number_of_grids);      % sets empty array for error approximations
    h_div = h;                                  % initializes first h = h
    for n=1:number_of_grids
        h_interval(n) = h_div;                  % replaces 0 in empty array with actual h/# value
        interval = -1+h_div : h_div : 1-h_div;  % makes fresh xi interval with h/# as gap
        if problem_number == 1      % If problem A, returns estimate vs actual for each xi based on h/# gap AND estimate and actual middle value for loglog graph
            [estimate_interval, actual_interval,estimate_middle,actual_middle] = ...
                problem_1(interval,h_div);
        elseif problem_number == 2  % If problem B...
            [estimate_interval, actual_interval,estimate_middle,actual_middle] = ...
                problem_2(interval,h_div);
        end
        error = (abs(estimate_middle-actual_middle))^(1.0/number_of_grids); % error approximation
        error_list(n) = error;                  % replaces 0 in empty error_list array with error approximation
        h_div = h/(n*2);                        % sets new h value (h/(2*grid_size))
    end
end

function [estimate_interval, actual_interval,estimate_middle,actual_middle] = ...
        problem_1(interval,h)                       % Problem A
    interval_length = length(interval);             % saves number of xi's in x_interval
    estimate_interval = zeros(1,length(interval));  % makes empty array for estimate f"(x)
    actual_interval = zeros(1,length(interval));    % makes empty array for actual f"(x)
    for n=1:interval_length
        xi = interval(n);                           % goes through each xi
        ui = problem_1_f(xi);                       % returns f(xi) for f"(xi) estimation
        ui_plus = problem_1_f(xi + h);              % returns f(xi+h) for f"(xi) estimation
        ui_minus = problem_1_f(xi - h);             % returns f(xi+h) for f"(xi) estimation
        estimate_interval(n) = f_double_prime(ui_plus,ui,ui_minus,h);   % estimate f"(xi)
        actual_interval(n) = problem_1_f_double_prime(xi);              % actual f"(xi)
    end
    estimate_middle = estimate_interval((interval_length+1)/2);         % since x_interval will always have an odd number of values,
    actual_middle = actual_interval((interval_length+1)/2);             % (interval_length+1)/2 will always return middle estimate/actual
end

function [estimate_interval, actual_interval,estimate_middle,actual_middle] = ...
        problem_2(interval,h)                       % Problem B
    interval_length = length(interval);             % ...
    estimate_interval = zeros(1,length(interval));
    actual_interval = zeros(1,length(interval));
    for n=1:interval_length
        xi = interval(n);
        ui = problem_2_f(xi);
        ui_plus = problem_2_f(xi + h);
        ui_minus = problem_2_f(xi - h);
        estimate_interval(n) = f_double_prime(ui_plus,ui,ui_minus,h);
        actual_interval(n) = problem_2_f_double_prime(xi);
    end
    estimate_middle = estimate_interval((interval_length+1)/2);
    actual_middle = actual_interval((interval_length+1)/2);
end

function result = f_double_prime(ui_plus,ui,ui_minus,h)
    result = (ui_plus - (2*ui) + ui_minus)/(h^2);   % centered finite difference approximation of f"(x)
end

function result = problem_1_f(x)
    result = exp(x)*sin((pi*x)/2);  % Returns f(x) for Problem A
end

function result = problem_1_f_double_prime(x)
    result = -(1/4) * exp(x)*(((pi^2)-4)*sin(pi*x/2)-4*pi*cos(pi*x/2)); % Returns actual f"(x) for Problem A
end

function result = problem_2_f(x)
    result = 2*(cos(pi*x)^2)-1;  % Returns f(x) for Problem B
end

function result = problem_2_f_double_prime(x)
    result = 4*(pi^2)*((sin(pi*x)^2)-(cos(pi*x)^2)); % Returns actual f"(x) for Problem B
end



##### SOURCE END #####
--></body></html>